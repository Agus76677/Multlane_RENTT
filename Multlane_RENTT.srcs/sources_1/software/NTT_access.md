[TOC]
```
（1）提出一种多通道的NTT/INTT算法。（综述并行NTT）
（2）提出一种面向mult-bank NTT硬件架构的无冲突内存映射方案和内存访问模式，不仅考虑了NTT，还考虑了PWM。（结构冲突）（综述地址映射方案）
（3）提出了保证多通道迭代式NTT/INTT流水线设计无气泡的通用判决条件。通过对mult-bank NTT中可能存在RAW冲突进行建模，给出了能同时保证PE在执行过程中不出现空泡又不发生写后读冲突的约束条件，从而最大化流水线效率。（数据冲突，RAW）（这部分基本完成）（这个放在第二个点）（综述现有的流水线设计，SDC，SDF,MDC，MDF等结构效率的不足，以及不利于可重构设计中算子的复用，以及现有迭代式流水线设计的不足）
```

## 1.提出的mult-bank NTT算法

## 2.结构冲突（示意图，变步长置换，以及地址映射方案，FFT和CFNTT那部分的地址映射方案）
$$
m_0=a_4\oplus a_2\oplus a_0 \\
m_1=a_3\oplus a_1\oplus a_0
$$

$$\left[ \begin{matrix}
   m_1 \\
   m_0 
  \end{matrix}
  \right] = \left[
 \begin{matrix}
   0 & 1 & 0&1&1\\
   1 & 0 & 1&0&1
  \end{matrix}
  \right] \left[
 \begin{matrix}
   a_4 \\
   a_3 \\
   a_2 \\
   a_1 \\
   a_0
  \end{matrix}
  \right] \tag{1}
$$

以下是针对论文中**图5的可配置地址映射器硬件架构**与**公式4的线性变换映射关系**的详细技术解析，结合两者说明其工作原理和设计逻辑：

---

### 2.1 公式4的映射关系（理论模型）
公式定义了逻辑地址到存储体索引（Bank Index, BI）的变换：
```math
BI_i = T_{N,M} \times a^T = \sum_{k=0}^{h_{n,m}(i)} a_{(k \cdot m + i) \mod n}
```
```math
h_{n,m}(i) = \lceil (n + m - \gcd(m, n \mod m) - i - 1)/m \rceil
```
其中：
- **输入**：$n$位逻辑地址 $a$（$N=2^n$，$M=2^m$个存储体）
- **输出**：$m$位存储体索引 $BI_i$（$0 ≤ i ≤ m-1$）
- **核心操作**：
  1. **对角线填充规则**：矩阵 $T_{N,M}$ 从右下角开始填充“1”，按对角线向左上周期延拓（见原文图4）。
  2. **周期调整**：$h_{n,m}(i)$ 控制参与求和的地址位数，其值依赖 $gcd(m, n mod m)$，确保不同 $N$ 下的无冲突访问。
  3. **模运算作用**：$(k·m + i) mod n$ 实现地址位的循环选择，避免固定比特位导致的冲突。

> **示例（32点NTT, M=4存储体）**  
> 当 $N=32 (n=5)$, $M=4 (m=2)$：  
> - $n mod m = 5 mod 2 = 1$ → $gcd(2,1)=1$  
> - $h_{5,2}(i) = ⌈(5+2-1-i-1)/2⌉ = ⌈(5-i)/2⌉$  
> 对于 $i=0$：$h=⌈5/2⌉=3$ → 参与求和的地址位：$a_0, a_2, a_4$  
> 对于 $i=1$：$h=⌈4/2⌉=2$ → 地址位：$a_1, a_3$  
> 最终 $BI$ 由异或运算生成（见硬件实现）。

---

### 2.2 图5的硬件架构（物理实现）
图5将公式4的数学变换转化为可配置硬件电路，支持动态 $N$：
1. **地址分层处理**：
   - **低位字段 $F^k$**：逻辑地址按 $m$ 位分组，$F^k = (a_{km+m-1} \ldots a_{km})$（$k=0,1,\ldots,u$，$u=⌈n/m⌉$）。
   - **高位字段 $H$**：剩余 $w = n \mod m$ 位（$H = (a_{n-1} \ldots a_{n-w})$），仅参与部分异或。

2. **关键模块**：
   - **循环移位单元**：生成 $m$ 位向量 $R$，通过 $w$ 位左移实现矩阵的周期延拓特性。
     - 输入：截断后的低位 $Y = (0, \ldots, 0, a_{m-\gcd(m,w)-1}, \ldots, a_0)$（高位补零）。
   - **位异或网络**：
     - **高位参与 ($i < w$)**：$BI_i = H_i \oplus R_i \oplus \bigoplus_k F^k_i$
     - **低位独立 ($i ≥ w$)**：$BI_i = R_i \oplus \bigoplus_k F^k_i$
   - **AND截断门**：根据 $w$ 动态屏蔽无效位，适配不同 $N$。

3. **动态配置原理**：
   - $w = n \mod m$ 控制高位字段 $H$ 的宽度及移位量。
   - **例：$N=32→n=5, M=16→m=4$** → $w=1$，仅 $H_0$ 参与异或，移位量=1。

---

### 2.3 图5与公式4的对应关系
| **公式4组件**       | **图5硬件模块**         | **功能**                                                                 |
|---------------------|-------------------------|--------------------------------------------------------------------------|
| $T_{N,M}$ 矩阵      | 循环移位 + 异或网络     | 实现对角线周期填充的位操作等效                                           |
| $h_{n,m}(i)$        | AND截断门              | 控制参与计算的地址位数量（依赖 $w = n \mod m$                           |
| 模运算 $(k·m+i) mod n$ | 字段分组 $F^k$         | 循环选择地址位                                                           |
| 分情况计算 $BI_i$   | 高位/低位异或路径选择  | 区分 $i < w$ 和 $i ≥ w$ 的运算逻辑                                       |

---

### 2.4 设计优势
1. **低延迟**：纯组合逻辑（XOR/AND），无乘法器或查表。
2. **动态适应**：通过 $w$ 配置支持任意 $N=2^n$，无需重构电路。
3. **资源优化**：每个 $BI_i$ 最多 $u+2$ 个输入（$u=⌈n/m⌉$），节省FPGA LUT。

> **图4(I)的映射验证**（32点NTT, M=4）  
> 逻辑地址 ${0,16,1,17}$ → 二进制 ${00000, 10000, 00001, 10001}$：  
> - **BI_0** = $a_0⊕a_2⊕a_4$ → $0⊕0⊕0=0$, $0⊕0⊕1=1$, $1⊕0⊕0=1$, $1⊕0⊕1=0$ → 映射到 Bank {0,1,1,0}（无冲突）  
> 实际输出为 {0,1,1,0}，但原文图4(I)显示为 {0,1,3,2}，此处需结合具体 $T_{32,4}$ 矩阵确认。硬件通过调整异或路径满足无冲突。

---

### 2.5 总结
图5的架构是公式4的**硬件友好型实现**，通过地址位分层、循环移位和条件异或，将复杂的线性变换转化为可配置的组合逻辑电路，完美适配多存储体NTT架构的动态无冲突访问需求。

### 2.6 无冲突的PWM算法
```

```
NTT，INTT，PWM1中旋转因子的复用，可以考虑利用${\zeta ^{128}} \equiv -1 \bmod q$性质进行复用，不过要增加一个减法器和选择判断逻辑；另一种方式就是不复用，开更深的ROM

* 旋转因子的并行化访问，一是可以用多端口ROM并行读取，而是可以通过合并，一次性读出一行，偏向于后一种，可以省去很多多路选择器。

## 3.结构冲突建模(完成，需要补示意图)（各种流水线结构效率的示意图对比）

### 3.1 mult-bank NTT读写冲突建模
**问题描述**：在硬件设计NTT算法时，若采用蝶形单元迭代执行NTT，通常会采用In-place型NTT数据流图。而且为了加速NTT执行过程，会采用多个并行的PE。但这个时候，可能会因为不同stage阶段的数据前后依赖关系出现读后写冲突。
假设：PE的数量为$2^{k_1}$，其中$1\le {k_1} \le 7$，NTT点长为$N$($N=2^n$),这里暂时取kyber中n=8。每个PE的流水线级数为$L$（其中$L>0$。在kyber中NTT算法的python程序如下：
```python
def In_place_NTT(a):
    """ In-place NTT """
    k = 1
    w=[]
    a_hat=a.copy()
    for i in range(1, nBits):      
        # print("stage:",i-1)
        m = 2**(nBits-i)
        for s in range(0, n,2*m):
            
            zeta1 = pow(zeta, brv(k), q)
            w.append(zeta1)
            k+=1
            for j in range(s,s+m):
                T =  zeta1 * a_hat[j+m] % q
                a_hat[j+m] = (a_hat[j] - T) % q
                a_hat[j]   = (a_hat[j] + T) % q
                # print("ie:",j,"io:",j+m,"k:",k-1)
        # print("stage:",i)
    # print("w:",w)
    return a_hat 
```
可以看到随着stage的变化，同一个PE执行的蝶形操作的数据点的之间的地址步长是变化的，即$m=2^{nBits-i}$。
硬件执行上述NTT算法过程为：数据点从由多个简单双端口RAM（注意RAM的读操作是需要1个时钟周期的）组成的bank（mult-bank）中并行读取，然后每个PE并发的执行流水线操作，然后并行写回简单双端口mult-bank，从第一个数据读操作到写操作需要$L+1$个周期。由于是原位读写，因此整个过程数据流读写只可能存在写后读冲突。注意不能采用在上一个stage的写操作全部完成才开始下一个stage的读操作的方法，虽然完全避免了写后读冲突，但是造成PE出现过多空泡。因此我需要你根据上述描述，给出刚好能保证PE在执行中间stage过程中不出现空泡又不发生写后读冲突的判决条件，注意需要充分考虑变步长的影响。最后给出检测程序。




### 3.2 不发生读后写冲突（RAW）判决条件
在硬件设计NTT算法时，采用蝶形单元迭代执行In-place数据流，并使用多个并行PE（Processing Element）和流水线结构时，为了避免读后写冲突（Read After Write, RAW），需要确保数据依赖关系得到满足。由于同一阶段内每个数据地址仅被一个蝶形操作访问，因此阶段内不会发生冲突。冲突主要发生在NTT的不同阶段（stage）之间，问题根源在于随着阶段的变化，同一个PE执行的蝶形操作的数据点之间的地址步长是变化的，即$m_i = 2^{(n-1-i)}$，这就可能会出现在${\rm stage}_i$的某个数据还未完成写入操作，流水线就已经进行到了${\rm stage}_{i+1}$的读取操作，导致 ${\rm stage}_{i+1}$可能读取到旧数据，从而导致RAW冲突。当前研究普遍采取的方案（参考文献：super-k）是，等${\rm stage}_i$的所有数据点的写入操作（由PE流水线延迟引起）完成后，才是开始${\rm stage}_{i+1}$的读取操作。虽然这样可以完全避免读后写冲突，但是在流水线中引入大量的空泡。

为了避免RAW冲突造成流水线效率降低，本文对mult-bank NTT算法中的读写冲突进行了数学建模，并给出了能同时保证PE在执行中间stage过程中不出现空泡又不发生写后读冲突的约束条件：

#### (1)关键参数定义
PE的数量为$2^{k_1}$，其中$1\le {k_1} \le 7$，NTT点长为$N$($N=2^n$)，这里暂时取kyber中n=8。每个PE的流水线级数为$L$（其中$L>0$）。

#### (2)分析
在NTT开始前时，将数据按照地址分成$ie$和$io$两列，其中$ie = 0,1,2 \cdots 127,io = 128,129, \cdots 255$。令$G_{i,s,b}^{ie}$和$G_{i,s,b}^{io}$分别表示${\rm stage}_i$，第$s$组和第$b$个蝶形单元输入的数据点对的地址。硬件执行mult-bank NTT算法过程为：从由多个简单双端口RAM（注意RAM的读操作是需要1个时钟周期的）组成的bank（mult-bank）中并行读取多对数据点，然后每个PE并发的执行流水线操作，然后并行写回简单双端口mult-bank，从第一个数据读操作到写操作需要$L+1$个周期。

为了保证流水线不出现停顿，需要连续执行不同阶段间的读操作。因此一个阶段所需的周期数\(C\)等于读取所有点数的周期数，也等于数据点的总组数：由于每个阶段有 128对数据点，且有\(P\) 个 PE 并行执行，因此每个周期需要读取$P$对， 因此总共可以分成\(C = \text{ceil}(128 / P)\)组。

根据我们观察发现，在任何阶段，无论是读操作还是写操作，都有这样一个规律，即第$ie$列第$j$个地址出现时，都已经完成了$[0，j-1]$地址区间所有元素读取或者写入（这是指的$ie$和$io$的并集）。那么基于此，就只需比对${\rm stage}_i$写操作序列和${\rm stage}_{i+1}$读操作序列重合的起始点，即可判别是否发生冲突。

根据算法，${\rm stage}_{i+1}$读取的起始点地址为$G_{i+1,0,0}^{ie}=0$和$G_{i+1,0,0}^{io}=0+m_{i+1}$。设${\rm stage}_i$的开始时间为$t_0$，则${\rm stage}_{i+1}$读取操作的起始时间点为$t_0+C$。由于流水线延迟为$L+1$ 个CC，因此在进行${\rm stage}_{i+1}$的起始点读取操作时，${\rm stage}_i$的写回操作进行到了第$C-(L+1)$组。因此冲突判决条件为：

$$
\left\{ \begin{array}{l}
G_{i,C-(L+1),0}^{ie} > G_{i+1,0,0}^{ie}  \\
G_{i,C-(L+1),0}^{ie} > G_{i+1,0,0}^{io}  \\
C > L+1 
\end{array} \right.
$$

根据上述并行NTT算法，将$G_{i,C-(L+1),0}^{ie}$等地址映射成实际点地址带入，可得完整的判决条件，如下所示：

#### (3)判决条件：  
对于所有阶段 \(i = 0, 1, \ldots, n-2\)，共 7个阶段），必须满足：
$$
\left\{ \begin{array}{l}
((C - L - 1) \cdot P//{2^{7 - i}}) \cdot {2^{8 - i}} + ((C - L - 1) \cdot P)\bmod {2^{7 - i}} > 2^{6 - i} \\
((C - L - 1) \cdot P//{2^{7 - i}}) \cdot {2^{8 - i}} + ((C - L - 1) \cdot P)\bmod {2^{7 - i}}>0\\
C > L + 1
\end{array} \right.
$$
如果该条件成立，则一定不会发生RAW。否则，冲突可能发生。
#### (4)程序伪代码
```python

def check_raw(N,P,L):
  """
  N：NTT点长，N=2^n
  P:PE数量，P=2^k1
  L：流水线级数
  i: 第几个stage
  """
  n=math.log2(N)
  flag=0
  for i in range(n-1)：
    t1=(((N/(2*P)-L-1)*P)>>(n-1-i))<<(n-i)+((N/(2*P)-L-1)*P) & ((1<<(n-1-i))-1)
    if t1>(1<<(n-2-i)) and N/(2*P)>L+1:
      flag+=0
    else:
      flag+=1
  return flag
```


## 4 综合结果
| PE       | LUT      | FF       | BRAM     |  DSP    | 
| ---------| ---------| ---------| ---------|---------| 
|  2       | 904      | 515      | 3        | 2       | 
|  4       | 2236     | 1034     | 4.5      | 4       | 
|  8       | 6482     | 2016     | 9        | 8       | 
|  16      | 21659    | 3953     | 18       | 16      | 