#!/usr/bin/env python3
"""Generate radix-4 twiddle ROM for N=256, q=3329.

Outputs both a .mem table (little-endian hex per 48-bit row) and a small Verilog
wrapper that infers a read-first ROM. A human-friendly tf_rom_debug.txt is also
produced so values can be spot-checked against radix4_notes.md.
"""
from __future__ import annotations

from dataclasses import dataclass
from pathlib import Path
from typing import Iterable, List

Q = 3329
N = 256
# Kyber uses 17 as a primitive root for q=3329. phi is a 2N-th root of unity.
PRIMITIVE_ROOT = 17
PHI = pow(PRIMITIVE_ROOT, (Q - 1) // (2 * N), Q)
OMEGA1 = pow(PHI, N // 4, Q)  # 4-th primitive root, matches radix4_notes
DATA_WIDTH = 12
P = 4  # 4PE configuration


@dataclass
class TwiddleVector:
    stage: int
    j: int
    w2: int
    w1: int
    w3: int
    omega1: int

    def pack(self) -> int:
        values = [self.w2, self.w1, self.w3, self.omega1]
        packed = 0
        for idx, val in enumerate(values):
            packed |= (val & ((1 << DATA_WIDTH) - 1)) << (idx * DATA_WIDTH)
        return packed

    def hex_width(self) -> str:
        width = (DATA_WIDTH * 4 + 3) // 4  # nibble count for 4 lanes
        return f"{self.pack():0{width}x}"


# We arrange addresses stage by stage: stage0 entries first, then stage1, etc.
# Each stage contributes 4**stage entries, matching the j-loop span.
def generate_twiddles() -> List[TwiddleVector]:
    vectors: List[TwiddleVector] = []
    for stage in range(4):
        J = 4**stage
        wm = pow(PHI, N // (4 * J), Q)
        for j in range(J):
            exponent = 2 * j + 1
            w1 = pow(wm, exponent, Q)
            w2 = pow(wm, 2 * exponent, Q)
            w3 = pow(wm, 3 * exponent, Q)
            vectors.append(TwiddleVector(stage, j, w2, w1, w3, OMEGA1))
    return vectors


def write_mem(vectors: Iterable[TwiddleVector], path: Path) -> None:
    with path.open("w") as f:
        for vec in vectors:
            f.write(f"{vec.hex_width()}\n")


def write_debug(vectors: Iterable[TwiddleVector], path: Path) -> None:
    with path.open("w") as f:
        current_stage = None
        for vec in vectors:
            if vec.stage != current_stage:
                current_stage = vec.stage
                f.write(f"stage {current_stage}:\n")
            f.write(
                f"  j={vec.j:02d} w2={vec.w2:4d} w1={vec.w1:4d} "
                f"w3={vec.w3:4d} omega1={vec.omega1:4d}\n"
            )


def write_verilog(mem_name: str, depth: int, path: Path) -> None:
    body = f"""`include \"parameter.v\"\n\nmodule tf_ROM_radix4 (\n    input clk,\n    input [7:0] A,\n    input REN,\n    output reg [({DATA_WIDTH}*4)-1:0] Q\n);\n    // Generated by gen_tf_rom_radix4.py\n    reg [({DATA_WIDTH}*4)-1:0] rom [0:{depth-1}];\n    initial $readmemh(\"{mem_name}.mem\", rom);\n\n    always @(posedge clk) begin\n        if (REN) Q <= rom[A];\n        else Q <= 'b0;\n    end\nendmodule\n"""
    with path.open("w") as f:
        f.write(body)


def main():
    vectors = generate_twiddles()
    mem_path = Path("tf_rom_radix4.mem")
    debug_path = Path("tf_rom_debug.txt")
    verilog_path = Path("tf_ROM_radix4.v")

    write_mem(vectors, mem_path)
    write_debug(vectors, debug_path)
    write_verilog(mem_path.stem, len(vectors), verilog_path)
    print(f"Generated {mem_path}, {debug_path}, {verilog_path}")


if __name__ == "__main__":
    main()
